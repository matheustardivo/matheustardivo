--- 
layout: post
title: "Fábricas de... software?"
wordpress_id: "14"
wordpress_url: http://tardivo.wordpress.com/2008/01/16/fabricas-de-software/
---
É impressionante ver que em pleno ano de 2008 existem pessoas que ainda acreditam em fábricas de software. Geralmente, estas pessoas tendem a permanecer alheias as <a href="http://pt.wikipedia.org/wiki/Desenvolvimento_%C3%A1gil_de_software" target="_blank">novas metodologias</a> - sei que o termo "novas" foi um pouco forte, afinal, pra ter uma idéia, o artigo "<a href="http://martinfowler.com/articles/newMethodology.html" target="_blank">The New Methodology</a>" de <a href="http://martinfowler.com" target="_blank">Martin Fowler</a> foi escrito no ano de 2000.

Fábricas de software sugerem que os desenvolvedores são apenas recursos que executam <a href="http://en.wikipedia.org/wiki/Code_monkey" target="_blank">tarefas manuais</a>, determinísticas e altamente especializadas. Isso funciona bem para carros, sapatos, mas não para software. A explicação para isso pode se tornar extensa e gera várias discussões, mas, no meu ponto de vista, é algo simples de entender: desenvolver software é essencialmente um trabalho de criação, que se assemelha mais a pintar um quadro ou escrever um livro.

Tentar tornar o trabalho de desenvolvimento de software altamente especializado e determinístico NÃO FUNCIONA!

A especialização é uma teoria que surgiu na <a href="http://pt.wikipedia.org/wiki/Revolu%C3%A7%C3%A3o_Industrial" target="_blank">revolução industrial</a> e funciona muito bem para o trabalho manual. Nela cada recurso executa uma pequena parte de um trabalho, muito especifico - <a href="http://pt.wikipedia.org/wiki/Modern_Times" target="_blank">como apertar parafusos</a>. Neste caso, o recurso pode ser facilmente substituído. No desenvolvimento de software o trabalho é essencialmente um processo de criação, uma arte. Por isso, essa teoria não encaixa.

A forma de especialização mais conhecida na área de desenvolvimento é a separação entre analista e programador. O analista é responsável por estudar os requisitos do sistema e gerar artefatos que transmitam a idéia para o programador - estes artefatos geralmente são diagramas <a href="http://pt.wikipedia.org/wiki/UML" target="_blank">UML</a> (diagramas de classes, diagramas de seqüência, diagramas de iteração) e <a href="http://pt.wikipedia.org/wiki/Casos_de_Uso" target="_blank">casos de uso</a>. Em posse desses artefatos, o programador apenas "transforma" tudo isso em código. Simples não? Parece ser. Mas então por que isso não funciona? Aliás, acabei de ler mais um ótimo post do <a href="http://blog.fragmental.com.br/" target="_blank">Phillip Calçado</a> sobre este assunto: <a href="http://blog.fragmental.com.br/2008/01/15/quando-eu-crescer-quero-ser-analista-de-sistemas/" target="_blank">Quando eu crescer quero ser Analista de Sistemas</a>.

O processo de criação de um software exige que a análise e o desenvolvimento andem o tempo todo juntos e sejam feitos de <a href="http://en.wikipedia.org/wiki/Waterfall_model" target="_blank">maneira incremental</a>. A análise é feita a medida que o desenvolvimento evoluí. Algo que foi analisado hoje, pode não ser mais válido daqui uma semana - ou até mesmo num tempo menor.

Para entender como funciona o processo de desenvolvimento incremental, ou melhor, iterativo, precisamos antes nos lembras dos velhos tempos: o estilo <a href="http://en.wikipedia.org/wiki/Waterfall_model" target="_blank">cascata</a>.

<i>"O <b>estilo em cascata</b> subdivide um projeto com base na atividades. Para construir software, você precisa realizar certas atividades: análise dos requisitos, projeto, codificação e teste. Assim, nosso projeto de um ano poderia ter uma fase de análise de dois meses, seguida de uma fase de projeto de quatro meses, após a qual viria uma fase de codificação de três meses, seguida de uma fase de teste de mais três meses.
No desenvolvimento em cascata, normalmente existe alguma espécie de transferência formal entre cada fase, mas freqüentemente existem refluxos. Durante a codificação, pode surgir algo que o faça rever a análise e o projeto. Você certamente não deve supor que todo o projeto esteja concluído, quando a codificação começa. É inevitável que as decisões de análise e projeto tenham de ser revistas nas fases posteriores. Entretanto, esses refluxos são exceções e devem ser minimizados o máximo possível."</i>

Essa definição sobre o estilo em cascata foi tirada do livro <a href="http://martinfowler.com/books.html#uml" target="_blank">UML Distilled: A Brief Guide to the Standard Object Modeling Language</a> de Martin Fowler. Então, nada mais justo que expor a definição sobre o estilo iterativo deste mesmo livro:

<i>"O <b>estilo iterativo</b> subdivide um projeto em subconjuntos de funcionalidades. Você poderia pegar um ano e dividi-lo em iterações de três meses. Na primeira iteração, você pegaria um quarto dos requisitos e faria o ciclo de vida do software completo para esse quarto: análise, projeto, código e teste. No final da primeira iteração você teria um sistema que faria um quarto da funcionalidade necessária. Então, você faria uma segunda iteração tal que, no final de seis meses, tivesse um sistema que fizesse metade da funcionalidade. É claro que o exposto é uma descrição simplificada, mas é a essência da diferença. Na prática, evidentemente, vazam algumas impurezas no processo.
No estilo iterativo, você normalmente vê alguma forma de atividade exploratória, antes que as iterações reais comecem. No mínimo, isso fornecerá uma visão de alto nível dos requisitos: pelo menos o suficiente para subdividi-los nas iterações que se seguirão. Algumas decisões de projeto de alto nível também podem ocorrer durante a exploração. Por outro lado, embora cada iteração deva gerar software integrado pronto para produção, freqüentemente ela não chega a esse ponto e precisa de um período de estabilização para eliminar os últimos erros. Além disso, algumas atividades, como o treinamento dos usuários, são deixadas para o final.
Você pode não colocar o sistema em produção ao final de cada iteração, mas eles devem ter qualidade de produção. Freqüentemente, entretanto, você pode colocar o sistema em produção em intervalos regulares; isso é bom, porque você avalia o sistema antecipadamente e obtém um retorno de melhor qualidade. Nessa situação, muitas vezes você ouve falar de um projeto com múltiplas versões, cada uma das quais subdivididas em várias iterações."</i>

Parando e refletindo sobre o assunto é interessante observar que muita coisa exposta neste texto e nos links abaixo não são exatamente grandes novidades. Essa é a realidade do desenvolvimento de software. Quem não entende isso ou não quer entender está completamente fora dessa realidade e deveria rever seus conceitos.

Alguns links sobre o assunto:
<ul>
	<li><a href="http://martinfowler.com/articles/newMethodology.html" target="_blank">The New Methodology</a> - tradução: <a href="http://simplus.com.br/artigos/a-nova-metodologia/" target="_blank">A Nova Metodologia</a> (<a href="http://martinfowler.com">Martin Fowler</a>)</li>
	<li><a href="http://martinfowler.com/articles/designDead.html" target="_blank">Is Design Dead?</a> (<a href="http://martinfowler.com">Martin Fowler</a>)</li>
	<li><a href="http://www.dtsato.com/blog/default/Agile/?permalink=Chega-de-Processos.html&amp;smm=y" target="_blank">Chega de Processos!</a> (<a href="http://www.dtsato.com" target="_blank">Danilo Sato</a>)</li>
	<li><a href="http://thiagoarrais.wordpress.com/2007/07/25/fabricas-de-software-uma-analogia-levada-longe-demais/" target="_blank">Fábricas de software - Uma analogia levada longe demais</a> (<a href="http://thiagoarrais.wordpress.com" target="_blank">Thiago Arrais</a>)</li>
	<li><a href="http://gc.blog.br/2007/06/08/como-produzir-software-coxa/" target="_blank">Como produzir software “coxa”</a> (<a href="http://gc.blog.br" target="_blank">Guilherme Chapiewski</a>)</li>
</ul>
